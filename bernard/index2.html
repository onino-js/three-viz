<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>WebGL Diffusion de Chaleur - Parois Fixes</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
      }
      .lil-gui {
        --widget-width: 300px;
      }
    </style>
  </head>
  <body>
    <canvas id="gl-canvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
      attribute vec2 a_position;
      varying vec2 v_texCoord;
      void main() {
          v_texCoord = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
      }
    </script>

    <script id="diffusion-shader" type="x-shader/x-fragment">
      precision highp float;
      varying vec2 v_texCoord;
      uniform sampler2D u_source;
      uniform vec2 u_texelSize;
      uniform float u_dt;
      uniform float u_diffusionRate;
      uniform float u_simHeight; // Ajout pour les conditions aux limites

      void main() {
          vec4 current_val = texture2D(u_source, v_texCoord);

          // Conditions aux limites de Dirichlet (température fixe)
          // On peut modifier la valeur de current_val aux bords avant le calcul du laplacien
          // ou l'appliquer après la diffusion.
          // Pour des raisons de stabilité et de clarté, il est souvent préférable
          // de l'appliquer soit en post-traitement, soit en affectant la valeur
          // directement sur le fragment aux bords.

          // Ici, on va l'appliquer après la diffusion. Le shader de diffusion calcule
          // la nouvelle valeur partout, et un shader de "boundaries" séparé
          // ou une logique dans le JavaScript pourrait fixer les bords.
          // Mais pour la diffusion simple, on va le faire directement ici.

          // Si nous sommes sur les bords Y (haut ou bas)
          // v_texCoord.y est entre 0.0 et 1.0
          // Si v_texCoord.y est très proche de 0.0 (bas) ou 1.0 (haut)
          float border_threshold = u_texelSize.y * 0.5; // Moitié d'un pixel

          if (v_texCoord.y < border_threshold) {
              gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Paroi chaude (température 1.0)
              return; // Sortir pour ne pas calculer la diffusion
          }
          if (v_texCoord.y > 1.0 - border_threshold) {
              gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Paroi froide (température 0.0)
              return; // Sortir
          }


          // Calcul du laplacien pour les points INTÉRIEURS
          vec4 vL = texture2D(u_source, v_texCoord - vec2(u_texelSize.x, 0.0));
          vec4 vR = texture2D(u_source, v_texCoord + vec2(u_texelSize.x, 0.0));
          vec4 vB = texture2D(u_source, v_texCoord - vec2(0.0, u_texelSize.y));
          vec4 vT = texture2D(u_source, v_texCoord + vec2(0.0, u_texelSize.y));
          vec4 laplacian = vL + vR + vB + vT - 4.0 * current_val;

          gl_FragColor = current_val + u_dt * u_diffusionRate * laplacian;

          // Pour les bords Gauche/Droite, CLAMP_TO_EDGE fait office de Neumann
          // Si on voulait Dirichlet aussi pour X, il faudrait des checks similaires pour v_texCoord.x
      }
    </script>

    <script id="visualize-shader" type="x-shader/x-fragment">
      precision mediump float;
      varying vec2 v_texCoord;
      uniform sampler2D u_temperature;

      vec3 colormap(float t) {
          t = clamp(t, 0.0, 1.0);
          return mix(
              vec3(0.2, 0.2, 0.8), // Froid (bleu)
              mix(
                  vec3(0.9, 0.9, 0.2), // Tiède (jaune)
                  vec3(0.8, 0.2, 0.2), // Chaud (rouge)
                  t
              ),
              t
          );
      }

      void main() {
          float temp = texture2D(u_temperature, v_texCoord).x;
          gl_FragColor = vec4(colormap(temp), 1.0);
      }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>

    <script type="module">
      const canvas = document.getElementById("gl-canvas");
      const gl = canvas.getContext("webgl");

      if (!gl) {
        alert("WebGL non supporté !");
      }

      const simParams = {
        RESOLUTION: 256,
        DIFFUSION_RATE: 0.5,
      };

      const ext = gl.getExtension("OES_texture_float");
      if (!ext) {
        alert("L'extension OES_texture_float est nécessaire !");
      }

      const programs = {};
      const quad = createQuad();
      let simWidth, simHeight;

      const temperature = {
        src: createTexture(),
        dst: createTexture(),
        fbo_src: gl.createFramebuffer(),
        fbo_dst: gl.createFramebuffer(),
      };

      // --- Fonctions utilitaires WebGL (inchangées) ---
      function createQuad() {
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
          gl.STATIC_DRAW
        );
        return buffer;
      }

      function createProgram(vertexId, fragmentId) {
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, document.getElementById(vertexId).textContent);
        gl.compileShader(vs);
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
          console.error(
            `Vertex Shader Error (${vertexId}):`,
            gl.getShaderInfoLog(vs)
          );

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, document.getElementById(fragmentId).textContent);
        gl.compileShader(fs);
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
          console.error(
            `Fragment Shader Error (${fragmentId}):`,
            gl.getShaderInfoLog(fs)
          );

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS))
          console.error(`Program Link Error:`, gl.getProgramInfoLog(program));

        return program;
      }

      function createTexture(data = null) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA, // Internal format
          simWidth,
          simHeight,
          0,
          gl.RGBA, // Format
          gl.FLOAT, // Type
          data
        );
        return texture;
      }

      function bindFBO(fbo, texture) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          texture,
          0
        );
        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) {
          console.error("Framebuffer non complet:", status);
        }
      }

      function swap(obj) {
        [obj.src, obj.dst] = [obj.dst, obj.src];
        [obj.fbo_src, obj.fbo_dst] = [obj.fbo_dst, obj.fbo_src];
      }

      function setupPositionAttribute(program) {
        const positionLocation = gl.getAttribLocation(program, "a_position");
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      }

      // --- Initialisation de la simulation ---

      function init() {
        programs.diffusion = createProgram("vertex-shader", "diffusion-shader");
        programs.visualize = createProgram("vertex-shader", "visualize-shader");

        resize();
        initData();

        const gui = new lil.GUI();
        gui
          .add(simParams, "RESOLUTION", [128, 256, 512])
          .name("Résolution")
          .onChange((v) => {
            simParams.RESOLUTION = Number(v);
            resize();
            initData(); // Réinitialiser les données après un redimensionnement
          });
        gui
          .add(simParams, "DIFFUSION_RATE", 0.01, 2.0)
          .name("Taux de Diffusion");

        requestAnimationFrame(update);
      }

      function resize() {
        simWidth = simParams.RESOLUTION;
        simHeight = simParams.RESOLUTION;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        gl.deleteTexture(temperature.src); // S'assurer de supprimer l'ancienne texture
        temperature.src = createTexture();
        gl.deleteTexture(temperature.dst); // S'assurer de supprimer l'ancienne texture
        temperature.dst = createTexture();

        // Les FBOs eux-mêmes n'ont pas besoin d'être recréés, juste leurs attachements mis à jour
        bindFBO(temperature.fbo_src, temperature.src);
        bindFBO(temperature.fbo_dst, temperature.dst);
      }

      function initData() {
        const tempArray = new Float32Array(simWidth * simHeight * 4);
        for (let j = 0; j < simHeight; j++) {
          for (let i = 0; i < simWidth; i++) {
            const idx = (j * simWidth + i) * 4;
            // Conditions aux limites de Dirichlet :
            if (j === 0) {
              // Bas de la grille (y=0)
              tempArray[idx] = 1.0; // Chaud (température 1.0)
            } else if (j === simHeight - 1) {
              // Haut de la grille (y=maxHeight)
              tempArray[idx] = 0.0; // Froid (température 0.0)
            } else {
              tempArray[idx] = 0.5; // Température neutre au milieu
            }
            tempArray[idx + 1] = 0.0; // G
            tempArray[idx + 2] = 0.0; // B
            tempArray[idx + 3] = 1.0; // A
          }
        }

        gl.bindTexture(gl.TEXTURE_2D, temperature.src);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          simWidth,
          simHeight,
          0,
          gl.RGBA,
          gl.FLOAT,
          tempArray
        );
      }

      // --- Boucle de Simulation ---

      function update() {
        gl.viewport(0, 0, simWidth, simHeight);

        const dt = 0.01;

        // 1. DIFFUSION DE LA TEMPÉRATURE
        gl.useProgram(programs.diffusion);
        setupPositionAttribute(programs.diffusion);
        gl.uniform2fv(
          gl.getUniformLocation(programs.diffusion, "u_texelSize"),
          [1.0 / simWidth, 1.0 / simHeight]
        );
        gl.uniform1f(gl.getUniformLocation(programs.diffusion, "u_dt"), dt);
        gl.uniform1f(
          gl.getUniformLocation(programs.diffusion, "u_diffusionRate"),
          simParams.DIFFUSION_RATE
        );
        gl.uniform1f(
          gl.getUniformLocation(programs.diffusion, "u_simHeight"),
          simHeight
        ); // Passer la hauteur pour le shader
        gl.uniform1i(gl.getUniformLocation(programs.diffusion, "u_source"), 0);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, temperature.src);

        bindFBO(temperature.fbo_dst, temperature.dst);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        swap(temperature);

        // 2. VISUALISATION
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.useProgram(programs.visualize);
        setupPositionAttribute(programs.visualize);
        gl.uniform1i(
          gl.getUniformLocation(programs.visualize, "u_temperature"),
          0
        );
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, temperature.src);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(update);
      }

      init();
    </script>
  </body>
</html>
